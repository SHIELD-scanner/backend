import os

from app.core.databaseClient import DatabaseClient
from app.models.old_vulnerability import Vulnerability


class VulnerabilityClient(DatabaseClient):
    def __init__(self):
        super().__init__()

    def get_collection(self):
        return self.client[os.getenv("MONGODB_DB", "shield")]["vulnerabilityreports"]

    def get_all(self, namespace: str = None, cluster: str = None, severity: str = None):
        query = {}
        if namespace:
            query["_namespace"] = namespace
        if cluster:
            query["_cluster"] = cluster
        if severity:
            # Filter by severity in the vulnerabilities array
            query["data.report.vulnerabilities.severity"] = severity

        items = self.get_collection().find(query, {"_id": 0})

        # Flatten the list since each document can contain multiple vulnerabilities
        all_vulnerabilities = []
        for item in items:
            vulnerabilities = self._format_to_vulnerability(item)
            if isinstance(vulnerabilities, list):
                all_vulnerabilities.extend(vulnerabilities)
            elif vulnerabilities is not None:
                all_vulnerabilities.append(vulnerabilities)

        return all_vulnerabilities

    def get_by_hash(self, hash: str):
        # Since hash is now generated from vulnerability data, we need to find the document
        # and then search through its vulnerabilities
        items = self.get_collection().find({}, {"_id": 0})

        for item in items:
            vulnerabilities = self._format_to_vulnerability(item)
            if isinstance(vulnerabilities, list):
                for vuln in vulnerabilities:
                    if vuln.hash == hash:
                        return vuln

        return None

    def _format_to_vulnerability(self, item):
        if item is None:
            return None

        # Extract vulnerabilities from the nested structure
        vulnerabilities = (
            item.get("data", {}).get("report", {}).get("vulnerabilities", [])
        )

        if not vulnerabilities:
            return []

        # Get metadata from the document
        cluster = item.get("_cluster", "")
        namespace = item.get("_namespace", "")
        pod_id = str(item.get("data", {}).get("metadata", {}).get("uid", ""))
        target = (
            item.get("data", {})
            .get("report", {})
            .get("artifact", {})
            .get("repository", "")
        )

        # Create a list to store all vulnerabilities from this report
        vulnerability_objects = []

        for vuln in vulnerabilities:
            # Create a hash for this specific vulnerability
            import hashlib

            hash_string = (
                f"{vuln.get('vulnerabilityID', '')}-{pod_id}-{vuln.get('resource', '')}"
            )
            vuln_hash = hashlib.md5(hash_string.encode()).hexdigest()

            vulnerability_data = {
                "fixedVersion": vuln.get("fixedVersion", ""),
                "installedVersion": vuln.get("installedVersion", ""),
                "lastModifiedDate": vuln.get("lastModifiedDate", ""),
                "links": vuln.get("links", []),
                "packagePURL": vuln.get("packagePURL", ""),
                "primaryLink": vuln.get("primaryLink", ""),
                "publishedDate": vuln.get("publishedDate", ""),
                "resource": vuln.get("resource", ""),
                "score": vuln.get("score", 0.0),
                "severity": vuln.get("severity", ""),
                "target": target,
                "vulnerabilityID": vuln.get("vulnerabilityID", ""),
                "pod_id": pod_id,
                "cluster": cluster,
                "namespace": namespace,
                "description": vuln.get("title", ""),  # Using 'title' as description
                "hash": vuln_hash,
            }

            try:
                vulnerability_objects.append(Vulnerability(**vulnerability_data))
            except Exception as e:
                print(f"Error creating vulnerability object: {e}")
                continue

        return vulnerability_objects
